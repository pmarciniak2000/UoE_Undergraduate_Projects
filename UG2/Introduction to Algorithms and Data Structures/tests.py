import math
import graph
import random
from datetime import datetime

numberOfFiles = 15#set this to the number of files you want to generate, more files will mean more reliable results but take more time
numNodes = 10#set this to number of nodes for metric cases

def testingEuclid(numberOfFiles,numNodes):

    for n in range(numberOfFiles):

        with open('test' + str(n), 'w') as newFile: #w+ or r+ if want to read?

            x = []#list of x coordinates
            y = []#list of y coordinates

            for i in range(numNodes):
                x.append(random.randint(0,50))
                y.append(random.randint(0,50))

            for val in range(len(x)):
                newFile.write(str(x[val]) + " " + str(y[val]) + "\n")

def testingNonMetric(numberOfFiles, numNodes):

    for n in range(numberOfFiles):

        with open('test' + str(n), 'w') as newFile: #w+ or r+ if want to read?

            x = []#list of x points
            y = []#list of y points
            w = []#list of weight(distances between points)

            for i in range(numNodes * numNodes): #set this to make sure that it generates enough nodes
                x.append(random.randint(0,numNodes))
                y.append(random.randint(0,numNodes))
                w.append(random.randint(0,200))

            for val in range(len(x)):
                newFile.write(str(x[val]) + " " + str(y[val]) + " " + str(w[val])  +"\n")


def averageCost(numberOfFiles):
    #function to calculate average tour cost generated by each individual algorithm
    originalAverage = 0
    swapAverage = 0
    twoOptAverage = 0
    greedyAverage = 0
    nearestInsertionAverage = 0

    for h in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(h)) #re-initialise graph each time to not affect results
        originalAverage += Grph.tourValue()
    
    for i in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(i)) #re-initialise graph each time to not affect results
        Grph.swapHeuristic()
        swapAverage += Grph.tourValue()

    for j in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(j)) #re-initialise graph each time to not affect results
        Grph.TwoOptHeuristic()
        twoOptAverage += Grph.tourValue()

    for k in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(k)) #re-initialise graph each time to not affect results
        Grph.Greedy()
        greedyAverage += Grph.tourValue()

    for l in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(l)) #re-initialise graph each time to not affect results
        Grph.NearestInsertion()
        nearestInsertionAverage += Grph.tourValue()
    
    print(originalAverage, "original")
    print(swapAverage, "swap")
    print(twoOptAverage,"2-opt")
    print(greedyAverage,"greedy")
    print(nearestInsertionAverage,"nearest insertion")

    #now find size of tour relative to original for each algorithm to determine average effectiveness
    #returns %(rounded to 2 decimal places) 
    swapEff = (swapAverage / originalAverage) * 100
    swapImp = 100 - swapEff
    print("swap: {}% of original tour value, {}% improvement over original".format(round(swapEff, 2), round(swapImp, 2)))

    twoOptEff = (twoOptAverage / originalAverage) * 100
    twoOptImp = 100 - twoOptEff
    print("twoOpt: {}% of original tour value, {}% improvement over original".format(round(twoOptEff, 2), round(twoOptImp, 2)))

    greedyEff = (greedyAverage / originalAverage) * 100
    greedyImp = 100 - greedyEff
    print("greedy: {}% of original tour value, {}% improvement over original".format(round(greedyEff, 2), round(greedyImp, 2)))

    nearestInsertionEff = (nearestInsertionAverage / originalAverage) * 100
    nearestInsertionImp = 100 - nearestInsertionEff
    print("nearestInsertion: {}% of original tour value, {}% improvement over original".format(round(nearestInsertionEff, 2), round(nearestInsertionImp, 2)))

def runTimes(numberOfFiles):
    swapTime = 0
    twoOptTime = 0
    greedyTime = 0
    nearestInsertionTime = 0
    
    startSwap = datetime.now()
    for i in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(i)) #re-initialise graph each time to not affect results
        Grph.swapHeuristic()
    swapTime = datetime.now() - startSwap
        
    startTwoOpt = datetime.now()
    for j in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(j)) #re-initialise graph each time to not affect results
        Grph.TwoOptHeuristic()
    twoOptTime = datetime.now() - startTwoOpt
        
    startGreedy = datetime.now()
    for k in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(k)) #re-initialise graph each time to not affect results
        Grph.Greedy()
    greedyTime = datetime.now() - startGreedy
        
    startNearest = datetime.now()
    for l in range(numberOfFiles):
        Grph = graph.Graph(-1, 'test' + str(l)) #re-initialise graph each time to not affect results
        Grph.NearestInsertion()
    nearestInsertionTime = datetime.now() - startNearest
        
    
    print(str(swapTime), "swap")
    print(str(twoOptTime),"2-opt")
    print(str(greedyTime),"greedy")
    print(str(nearestInsertionTime),"nearest insertion")

#set which elements you want to test here, i.e. comment out the things you dont want to test

testingEuclid(numberOfFiles,numNodes)
#testingNonMetric(numberOfFiles, numNodes)
averageCost(numberOfFiles)
#runTimes(numberOfFiles)

